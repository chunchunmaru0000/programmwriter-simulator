Строка представляет последовательность символов в кодировке Unicode, заключенных в кавычки. Причем для определения строк Python позволяет использовать как одинарные, так и двойные кавычики:
<code///>
message = "Hello World!"
print(message)  # Hello World!
 
name = 'Tom'
print(name)  # Tom
<code///>
Если строка длинная, ее можно разбить на части и разместить их на разных строках кода. В этом случае вся строка заключается в круглые скобки, а ее отдельные части - в кавычки:
<code///>
text = ("Laudate omnes gentes laudate "
        "Magnificat in secula ")
print(text)
<code///>
Если же мы хотим определить многострочный текст, то такой текст заключается в тройные двойные или одинарные кавычки:
<code///>
'''
Это комментарий
'''
text = '''Laudate omnes gentes laudate
Magnificat in secula
Et anima mea laudate
Magnificat in secula 
'''
print(text)
<code///>
При использовани тройных одинарных кавычек не стоит путать их с комментариями: если текст в тройных одинарных кавычках присваивается переменной, то это строка, а не комментарий.
Управляющие последовательности в строке

Строка может содержать ряд специальных символов - управляющих последовательностей или escape-последовательности. Некоторые из них:

    \: позволяет добавить внутрь строки слеш

    \': позволяет добавить внутрь строки одинарную кавычку

    \": позволяет добавить внутрь строки двойную кавычку

    \n: осуществляет переход на новую строку

    \t: добавляет табуляцию (4 отступа)

Используем некоторые последовательностей:
<code///>
text = "Message:\n\"Hello World\""
print(text)
<code///>
Консольный вывод программы:

Message:
"Hello World"

Хотя подобные последовательности могут нам помочь в некоторых делах, например, поместить в строку кавычку, сделать табуляцию, перенос на другую строку. Но они также могут и мешать. Например:
<code///>
path = "C:\python\name.txt"
print(path)
<code///>
Здесь переменная path содержит некоторый путь к файлу. Однако внутри строки встречаются символы "\n", которые будут интерпретированы как управляющая последовательность. Так, мы получим следующий консольный вывод:

C:\python
ame.txt

Чтобы избежать подобной ситуации, перед строкой ставится символ r
<code///>
path = r"C:\python\name.txt"
print(path)
<code///>
Вставка значений в строку

Python позволяет встравивать в строку значения других переменных. Для этого внутри строки переменные размещаются в фигурных скобках {}, а перед всей строкой ставится символ f:
<code///>
userName = "Tom"
userAge = 37
user = f"name: {userName}  age: {userAge}"
print(user)   # name: Tom  age: 37
<code///>
В данном случае на место {userName} будет вставляться значение переменной userName. Аналогично на вместо {userAge} будет вставляться значение переменной userAge.
Обращение к символам строки

И мы можем обратиться к отдельным символам строки по индексу в квадратных скобках:
<code///>
string = "hello world"
c0 = string[0]  # h
print(c0)
c6 = string[6]  # w
print(c6)
 
c11 = string[11]  # ошибка IndexError: string index out of range
print(c11)
<code///>
Индексация начинается с нуля, поэтому первый символ строки будет иметь индекс 0. А если мы попытаемся обратиться к индексу, которого нет в строке, то мы получим исключение IndexError. Например, в случае выше длина строки 11 символов, поэтому ее символы будут иметь индексы от 0 до 10.

Чтобы получить доступ к символам, начиная с конца строки, можно использовать отрицательные индексы. Так, индекс -1 будет представлять последний символ, а -2 - предпоследний символ и так далее:
<code///>
string = "hello world"
c1 = string[-1]  # d
print(c1)
c5 = string[-5]  # w
print(c5)
<code///>
При работе с символами следует учитывать, что строка - это неизменяемый (immutable) тип, поэтому если мы попробуем изменить какой-то отдельный символ строки, то мы получим ошибку, как в следующем случае:
<code///>
string = "hello world"
string[1] = "R"
<code///>
Мы можем только полностью переустановить значение строки, присвоив ей другое значение.
Перебор строки

С помощью цикла for можно перебрать все символы строки:
<code///>
string = "hello world"
for char in string:
    print(char)
<code///>
Получение подстроки

При необходимости мы можем получить из строки не только отдельные символы, но и подстроку. Для этого используется следующий синтаксис:

    string[:end]: извлекается последовательность символов начиная с 0-го индекса по индекс end (не включая)

    string[start:end]: извлекается последовательность символов начиная с индекса start по индекс end (не включая)

    string[start:end:step]: извлекается последовательность символов начиная с индекса start по индекс end (не включая) через шаг step

Используем все варианты получения подстроки:
<code///>
string = "hello world"
 
# с 0 до 5 индекса
sub_string1 = string[:5]
print(sub_string1)      # hello
 
# со 2 до 5 индекса
sub_string2 = string[2:5]
print(sub_string2)      # llo
 
# с 2 по 9 индекса через один символ
sub_string3 = string[2:9:2]
print(sub_string3)      # lowr
<code///>
Объединение строк

Одной из самых распространенных операций со строками является их объединение или конкатенация. Для объединения строк применяется операция сложения:
<code///>
name = "Tom"
surname = "Smith"
fullname = name + " " + surname
print(fullname)  # Tom Smith
<code///>
С объединением двух строк все просто, но что, если нам надо сложить строку и число? В этом случае необходимо привести число к строке с помощью функции str():
<code///>
name = "Tom"
age = 33
info = "Name: " + name + " Age: " + str(age)
print(info)  # Name: Tom Age: 33
<code///>
Повторение строки

Для повторения строки определенное количество раз применяется операция умножения:
<code///>
print("a" * 3)  # aaa
print("he" * 4)  # hehehehe
<code///>
Сравнение строк

Особо следует сказать о сравнении строк. Сравнение производится в лексикографическом порядке. При сравнении строк принимается во внимание символы и их регистр. Так, цифровой символ условно меньше, чем любой алфавитный символ. Алфавитный символ в верхнем регистре условно меньше, чем алфавитные символы в нижнем регистре. Например:
<code///>
str1 = "1a"
str2 = "aa"
str3 = "Aa"
print(str1 > str2)  # False, так как первый символ в str1 - цифра
print(str2 > str3)  # True, так как первый символ в str2 - в нижнем регистре
<code///>
Поэтому строка "1a" условно меньше, чем строка "aa". Вначале сравнение идет по первому символу. Если начальные символы обоих строк представляют цифры, то меньшей считается меньшая цифра, например, "1a" меньше, чем "2a".

Если начальные символы представляют алфавитные символы в одном и том же регистре, то смотрят по алфавиту. Так, "aa" меньше, чем "ba", а "ba" меньше, чем "ca".

Если первые символы одинаковые, в расчет берутся вторые символы при их наличии.

Зависимость от регистра не всегда желательна, так как по сути мы имеем дело с одинаковыми строками. В этом случае перед сравнением мы можем привести обе строки к одному из регистров.

Функция lower() приводит строку к нижнему регистру, а функция upper() - к верхнему.
<code///>
str1 = "Tom"
str2 = "tom"
print(str1 == str2)  # False - строки не равны
 
print(str1.lower() == str2.lower())  # True
<code///>
Функции ord и len

Поскольку строка содержит символы Unicode, то с помощью функции ord() мы можем получить числовое значение для символа в кодировке Unicode:
<code///>
print(ord("A"))     # 65
<code///>
Для получения длины строки можно использовать функцию len():
<code///>
string = "hello world"
length = len(string)
print(length)   # 11
<code///>
Поиск в строке

С помощью выражения term in string можно найти подстроку term в строке string. Если подстрока найдена, то выражение вернет значение True, иначе возвращается значение False:
<code///>
text = "hello world"
exist = "hello" in text
print(exist)    # True
 
exist = "sword" in text
print(exist)    # False
<code///>
Соответственно с помощью операторов not in можно проверить отсутствие подстроки в строке:
<code///>
text = "hello world"
print("hello" not in text)    # False
print("sword" not in text)    # True
<code///>
Рассмотрим основные методы строк, которые мы можем применить в приложениях:

    isalpha(): возвращает True, если строка состоит только из алфавитных символов

    islower(): возвращает True, если строка состоит только из символов в нижнем регистре

    isupper(): возвращает True, если все символы строки в верхнем регистре

    isdigit(): возвращает True, если все символы строки - цифры

    isnumeric(): возвращает True, если строка представляет собой число

    startswith(str): возвращает True, если строка начинается с подстроки str

    endswith(str): возвращает True, если строка заканчивается на подстроку str

    lower(): переводит строку в нижний регистр

    upper(): переводит строку в вехний регистр

    title(): начальные символы всех слов в строке переводятся в верхний регистр

    capitalize(): переводит в верхний регистр первую букву только самого первого слова строки

    lstrip(): удаляет начальные пробелы из строки

    rstrip(): удаляет конечные пробелы из строки

    strip(): удаляет начальные и конечные пробелы из строки

    ljust(width): если длина строки меньше параметра width, то справа от строки добавляются пробелы, чтобы дополнить значение width, а сама строка выравнивается по левому краю

    rjust(width): если длина строки меньше параметра width, то слева от строки добавляются пробелы, чтобы дополнить значение width, а сама строка выравнивается по правому краю

    center(width): если длина строки меньше параметра width, то слева и справа от строки равномерно добавляются пробелы, чтобы дополнить значение width, а сама строка выравнивается по центру

    find(str[, start [, end]): возвращает индекс подстроки в строке. Если подстрока не найдена, возвращается число -1

    replace(old, new[, num]): заменяет в строке одну подстроку на другую

    split([delimeter[, num]]): разбивает строку на подстроки в зависимости от разделителя

    partition(delimeter): разбивает строку по разделителю на три подстроки и возвращает кортеж из трех элементов - подстрока до разделителя, разделитель и подстрока после разделителя

    join(strs): объединяет строки в одну строку, вставляя между ними определенный разделитель

Например, если мы ожидаем ввод с клавиатуры числа, то перед преобразованием введенной строки в число можно проверить, с помощью метода isnumeric() введено ли в действительности число, и если так, то выполнить операцию преобразования:
<code///>
string = input("Введите число: ")
if string.isnumeric():
    number = int(string)
    print(number)
<code///>
Проверка, начинается или оканчивается строка на определенную подстроку:
<code///>
file_name = "hello.py"
 
starts_with_hello = file_name.startswith("hello")   # True
ends_with_exe = file_name.endswith("exe")           # False
<code///>
Удаление пробелов в начале и в конце строки:
<code///>
string = "   hello  world!  "
string = string.strip()
print(string)           # hello  world!
<code///>
Дополнение строки пробелами и выравнивание:
<code///>
print("iPhone 7:", "52000".rjust(10))
print("Huawei P10:", "36000".rjust(10))
<code///>
Консольный вывод:

iPhone 7:      52000
Huawei P10:      36000

Поиск в строке

Для поиска подстроки в строке в Python применяется метод find(), который возвращает индекс первого вхождения подстроки в строку и имеет три формы:

    find(str): поиск подстроки str ведется с начала строки до ее конца

    find(str, start): параметр start задает начальный индекс, с которого будет производиться поиск

    find(str, start, end): параметр end задает конечный индекс, до которого будет идти поиск

Если подстрока не найдена, метод возвращает -1:
<code///>
welcome = "Hello world! Goodbye world!"
index = welcome.find("wor")
print(index)       # 6
 
# поиск с 10-го индекса
index = welcome.find("wor",10)
print(index)       # 21
 
# поиск с 10 по 15 индекс
index = welcome.find("wor",10,15)
print(index)       # -1
<code///>
Замена в строке

Для замены в строке одной подстроки на другую применяется метод replace():

    replace(old, new): заменяет подстроку old на new

    replace(old, new, num): параметр num указывает, сколько вхождений подстроки old надо заменить на new. По умолчанию num равно -1, что соответствует первой версии метода и приводит к замене всех вхождений.
<code///>
phone = "+1-234-567-89-10"
 
# замена дефисов на пробел
edited_phone = phone.replace("-", " ")
print(edited_phone)     # +1 234 567 89 10
 
# удаление дефисов
edited_phone = phone.replace("-", "")
print(edited_phone)     # +12345678910
 
# замена только первого дефиса
edited_phone = phone.replace("-", "", 1)
print(edited_phone)     # +1234-567-89-10
<code///>
Разделение на подстроки

Метод split() разбивает строку на список подстрок в зависимости от разделителя. В качестве разделителя может выступать любой символ или последовательность символов. Данный метод имеет следующие формы:

    split(): в качестве разделителя используется пробел

    split(delimeter): в качестве разделителя используется delimeter

    split(delimeter, num): параметр num указывает, сколько вхождений delimeter используется для разделения. Оставшаяся часть строки добавляется в список без разделения на подстроки

<code///>
text = "Это был огромный, в два обхвата дуб, с обломанными ветвями и с обломанной корой"
# разделение по пробелам
splitted_text = text.split()
print(splitted_text)
print(splitted_text[6])     # дуб,
 
# разбиение по запятым
splitted_text = text.split(",")
print(splitted_text)
print(splitted_text[1])     # в два обхвата дуб
 
# разбиение по первым пяти пробелам
splitted_text = text.split(" ", 5)
print(splitted_text)        
print(splitted_text[5])     # обхвата дуб, с обломанными ветвями и с обломанной корой
<code///>
Еще один метод - partition() разбивает строку по разделителю на три подстроки и возвращает кортеж из трех элементов - подстрока до разделителя, разделитель и подстрока после разделителя:
<code///>
text = "Это был огромный, в два обхвата дуб, с обломанными ветвями и с обломанной корой"
text_parts = text.partition("дуб")
print(text_parts)
# ('Это был огромный, в два обхвата ', 'дуб', ', с обломанными ветвями и с обломанной корой')
<code///>
Если разделитель с строке не найден, то возвращается кортеж с одной строкой.
Соединение строк

При рассмотрении простейших операций со строками было показано, как объединять строки с помощью операции сложения. Другую возможность для соединения строк представляет метод join(): он объединяет список строк. Причем текущая строка, у которой вызывается данный метод, используется в качестве разделителя:
<code///>
words = ["Let", "me", "speak", "from", "my", "heart", "in", "English"]
 
# разделитель - пробел
sentence = " ".join(words)
print(sentence)  # Let me speak from my heart in English
 
# разделитель - вертикальная черта
sentence = " | ".join(words)
print(sentence)  # Let | me | speak | from | my | heart | in | English
<code///>
Вместо списка в метод join можно передать простую строку, тогда разделитель будет вставляться между символами этой строки:
<code///>
word = "hello"
joined_word = "|".join(word)
print(joined_word)      # h|e|l|l|o
<code///>
В прошлых темах было рассмотрено, как можно вставлять в строку некоторые значения, предваряя строку символом f:
<code///>
first_name="Tom"
text = f"Hello, {first_name}."
print(text)     # Hello, Tom.
 
name="Bob"
age=23
info = f"Name: {name}\t Age: {age}"
print(info)     # Name: Bob  Age: 23
<code///>
Но также в Python есть альтернативный способ, который предоставляет метод format(). Этот метод позволяет форматировать строку, вставляя в нее на место плейсхолдеров определенные значения.

Для вставки в строку используются специальные параметры, которые обрамляются фигурными скобками ({}).
Именованные параметры

В форматируемой строке мы можем определять параметры, в методе format() передавать для этих параметров значения:
<code///>
text = "Hello, {first_name}.".format(first_name="Tom")
print(text)     # Hello, Tom.
 
info = "Name: {name}\t Age: {age}".format(name="Bob", age=23)
print(info)     # Name: Bob  Age: 23
<code///>
Причем в метод формат аргументы определяются с тем же именем, что и параметры в строке. Так, если параметр называется first_name, как в первом случае, то аргумент, которому присваивается значение, также называется first_name.
Параметры по позиции

Мы также можем последовательно передавать в метод format набор аргументов, а в самой форматируемой строке вставлять эти аргумента, указывая в фигурных скобках их номер (нумерация начинается с нуля):
<code///>
info = "Name: {0}\t Age: {1}".format("Bob", 23)
print(info)     # Name: Bob  Age: 23
<code///>
При этом аргументы можно вставлять в строку множество раз:
<code///>	
text = "Hello, {0} {0} {0}.".format("Tom")
<code///>
Подстановки

Еще один способ передачи форматируемых значений в строку представляет использование подстановок или специальных плейсхолдеров, на место которых вставляются определенные значения. Для форматирования мы можем использовать следующие плейсхолдеры:

    s: для вставки строк

    d: для вставки целых чисел

    f: для вставки дробных чисел. Для этого типа также можно определить через точку количество знаков в дробной части.

    %: умножает значение на 100 и добавляет знак процента

    e: выводит число в экспоненциальной записи

Общий синтаксис плейсхолдера следующий:
<code///>
{:плейсхолдер}
<code///>
В зависимости от плейсхолдера можно добавлять дополнительные параметры. Например, для форматирования чисел float можно использовать следующие параметры
<code///>	
{:[количество_символов][запятая][.число_знаков_в_дробной_части] плейсхолдер}
<code///>
При вызове метода format в него в качестве аргументов передаются значения, которые вставляются на место плейсхолдеров:
<code///>
welcome = "Hello {:s}"
name = "Tom"
formatted_welcome = welcome.format(name)
print(formatted_welcome)        # Hello Tom
<code///>
В качестве результата метод format() возвращает новую отформатированную строку.

Форматирование целых чисел:
<code///>	
source = "{:d} символов"
number = 5
target = source.format(number)
print(target)   # 5 символов
<code///>
Если форматируемое число больше 999, то мы можем указать в определении плейсхолдера, что мы хотим использовать запятую в качестве разделителя разрядов:
<code///>
source = "{:,d} символов"
print(source.format(5000))   # 5,000 символов
<code///>
Причем плейсхолдеры можно использовать и в f-строках:
<code///>
n = 5000
source = f"{n:,d} символов"
print(source)   # 5,000 символов
<code///>
Для дробных чисел, то есть таких, которые представляют тип float, перед кодом плейсхолдера после точки можно указать, сколько знаков в дробной части мы хотим вывести:
<code///>
number = 23.8589578
print("{:.2f}".format(number))   # 23.86
print("{:.3f}".format(number))   # 23.859
print("{:.4f}".format(number))   # 23.8590
print("{:,.2f}".format(10001.23554))    # 10,001.24
<code///>
Еще один параметр позволяет установить минимальную ширину форматируемого значения в символах:
<code///>
print("{:10.2f}".format(23.8589578))    #     23.86
print("{:8d}".format(25))               #      25
<code///>
Аналогичный пример с f-строками:
<code///>
n1 = 23.8589578
print(f"{n1:10.2f}")    #     23.86
n2 = 25
print(f"{n2:8d}")       #      25
<code///>
Для вывода процентов лучше воспользоваться кодом "%":
<code///>
number = .12345
print("{:%}".format(number))        # 12.345000%
print("{:.0%}".format(number))      # 12%
print("{:.1%}".format(number))      # 12.3%
 
print(f"{number:%}")        # 12.345000%
print(f"{number:.0%}")      # 12%
print(f"{number:.1%}")      # 12.3%
<code///>
Для вывода числа в экспоненциальной записи применяется плейсхолдер "e":
<code///>
number = 12345.6789
print("{:e}".format(number))        # 1.234568e+04
print("{:.0e}".format(number))      # 1e+04
print("{:.1e}".format(number))      # 1.2e+04
 
print(f"{number:e}")        # 1.234568e+04
print(f"{number:.0e}")      # 1e+04
print(f"{number:.1e}")      # 1.2e+04
<code///>
Форматирование без метода format

Существует также еще один способ форматирования с помощью следующего синтаксиса:
<code///>	
строка%(параметр1, параметр2,..параметрN)
<code///>
То есть в начале идет строка, которая содержит те же плейсхолдеры, которые были рассмотрены выше (за исключением плейсхолдера %), после строки ставится знак процента %, а затем список значений, которые вставляются в строку. Фактически знак процента представляют операцию, в результате которой образуется новая строка:
<code///>	
info = "Имя: %s \t Возраст: %d" % ("Tom", 35)Hello World     !
print(info)   # Имя: Tom     Возраст: 35
<code///>
Рядом с плейсхолдером указывается знак процента и в отличие от функции format здесь не требуются фигурные скобки.

Причем способы форматирования чисел здесь также применяются:
<code///>
number = 23.8589578
print("%0.2f  - %e" % (number, number))   # 23.86  - 2.385896e+01
<code///>
Установка длины строки

С помощью специальных символов можно задать длину строки при форматировании:

    <N: выравнивает строку по левому краю и дополняет ее пробелами с правой стороны до длины N

    >N: выравнивает строку по правому краю и дополняет ее пробелами с левой стороны до длины N

    ^N: выравнивает строку по центру и дополняет ее пробелами с левой и правой стороны до длины N

    .N: задает точную длину строки. Если в ней больше N символов, то она усекается

Например:
<code///>
str = "Hello World"
print(f"{str:>16}!")     
print(f"{str:<16}!")   
print(f"{str:^16}!")
print(f"{str:.16}!") 
print(f"{str:.5}!") 
<code///>
Результат:

    Hello World!
Hello World    !
  Hello World  !
Hello World!
Hello!