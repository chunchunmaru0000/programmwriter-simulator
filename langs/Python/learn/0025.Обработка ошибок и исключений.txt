При программировании на Python мы можем столкнуться с двумя типами ошибок. Первый тип представляют синтаксические ошибки (syntax error). Они появляются в результате нарушения синтаксиса языка программирования при написании исходного кода. При работе в какой-либо среде разработки, например, в PyCharm, IDE сама может отслеживать синтаксические ошибки и каким-либо образом их выделять.

Второй тип ошибок представляют ошибки выполнения (runtime error). Они появляются в уже в процессе выполнения программы. Подобные ошибки еще называются исключениями. Например, в прошлых темах мы рассматривали преобразование строки в число:
<code///>	
string = "5"
number = int(string)
print(number)
<code///>
Данный скрипт успешно выполнится, так как строка "5" вполне может быть конвертирована в число. Однако возьмем другой пример:
<code///>
string = "hello"
number = int(string)
print(number)
<code///>
При выполнении этого скрипта будет выброшено исключение ValueError, так как строку "hello" нельзя преобразовать в число:
<code///>	
ValueError: invalid literal for int() with base 10: 'hello'
<code///>
С одной стороны, здесь очевидно, что строка не представляет число, но мы можем иметь дело с вводом пользователя, который также может ввести не совсем то, что мы ожидаем:
<code///>	
string = input("Введите число: ")
number = int(string)
print(number)
<code///>
При возникновении исключения работа программы прерывается, и чтобы избежать подобного поведения и обрабатывать исключения в Python есть конструкция try..except.
try..except

Конструкция try..except имеет следующее формальное определение:
<code///>	
try:
    инструкции
except [Тип_исключения]:
    инструкции
<code///>
Весь основной код, в котором потенциально может возникнуть исключение, помещается после ключевого слова try. Если в этом коде генерируется исключение, то работа кода в блоке try прерывается, и выполнение переходит в блок except.

После ключевого слова except опционально можно указать, какое исключение будет обрабатываться (например, ValueError или KeyError). После слова except на следующей стоке идут инструкции блока except, выполняемые при возникновении исключения.

Рассмотрим обработку исключения на примере преобразовании строки в число:
<code///>	
try:
    number = int(input("Введите число: "))
    print("Введенное число:", number)
except:
    print("Преобразование прошло неудачно")
print("Завершение программы")
<code///>
Вводим строку:

Введите число: hello
Преобразование прошло неудачно
Завершение программы

Как видно из консольного вывода, при вводе строки вывод числа на консоль не происходит, а выполнение программы переходит к блоку except.

Вводим правильное число:

Введите число: 22
Введенное число: 22
Завершение программы

Теперь все выполняется нормально, исключение не возникает, и соответственно блок except не выполняется.
Блок finally

При обработке исключений также можно использовать необязательный блок finally. Отличительной особенностью этого блока является то, что он выполняется вне зависимости, было ли сгенерировано исключение:
<code///>	
try:
    number = int(input("Введите число: "))
    print("Введенное число:", number)
except:
    print("Преобразование прошло неудачно")
finally:
    print("Блок try завершил выполнение")
print("Завершение программы")
<code///>
Как правило, блок finally применяется для освобождения используемых ресурсов, например, для закрытия файлов.

Стоит отметить, что блок finally не обрабатывает исключения, и если мы используем этот блок без блока except, то при возникновении ошибки приложение аварийно завершится, как в следующем случае при делении числа на ноль:
<code///>	
try:
    number = 3/0    # генерирует исключение ZeroDivisionError
    print(number)
finally:
    print("Блок try завершил выполнение")
print("Завершение программы")
<code///>
строенные типы исключений

В примере выше обрабатывались сразу все исключения, которые могут возникнуть в коде. Однако мы можем конкретизировать тип обрабатываемого исключения, указав его после слова except:
<code///>
try:
    number = int(input("Введите число: "))
    print("Введенное число:", number)
except ValueError:
    print("Преобразование прошло неудачно")
print("Завершение программы")
<code///>
В данном случае блок execpt обрабатывает только исключения типа ValueError, которые могут возникнут при неудачном преобразовании строки в число.

В Python есть следующие базовые типы исключений:
<code///>
    BaseException: базовый тип для всех встроенных исключений

    Exception: базовый тип, который обычно применяется для создания своих типов исключений

    ArithmeticError: базовый тип для исключений, связанных с арифметическими операциями (OverflowError, ZeroDivisionError, FloatingPointError).

    BufferError: тип исключения, которое возникает при невозможности выполнить операцию с буффером

    LookupError: базовый тип для исключений, которое возникают при обращении в коллекциях по некорректному ключу или индексу (например, IndexError, KeyError)

От этих классов наследуются все конкретные типы исключений. В Python обладает довольно большим списком встроенных исключений. Весь этот список можно посмотреть в документации. Перечислю только некоторые наиболее часто встречающиеся:

    IndexError: исключение возникает, если индекс при обращении к элементу коллекции находится вне допустимого диапазона

    KeyError: возникает, если в словаре отсутствует ключ, по которому происходит обращение к элементу словаря.

    OverflowError: возникает, если результат арифметической операции не может быть представлен текущим числовым типом (обычно типом float).

    RecursionError: возникает, если превышена допустимая глубина рекурсии.

    TypeError: возникает, если операция или функция применяется к значению недопустимого типа.

    ValueError: возникает, если операция или функция получают объект корректного типа с некорректным значением.

    ZeroDivisionError: возникает при делении на ноль.

    NotImplementedError: тип исключения для указания, что какие-то методы класса не реализованы

    ModuleNotFoundError: возникает при при невозможности найти модуль при его импорте директивой import

    OSError: тип исключений, которые генерируются при возникновении ошибок системы (например, невозможно найти файл, память диска заполнена и т.д.)
<code///>
И если ситуация такова, что в программе могут быть сгенерированы различные типы исключений, то мы можем их обработать по отдельности, используя дополнительные выражения except. И при возникновении исключения Python будет искать нужный блок except, который обрабатывает данный тип исключения:
<code///>	
try:
    number1 = int(input("Введите первое число: "))
    number2 = int(input("Введите второе число: "))
    print("Результат деления:", number1/number2)
except ValueError:
    print("Преобразование прошло неудачно")
except ZeroDivisionError:
    print("Попытка деления числа на ноль")
except BaseException:
    print("Общее исключение")
print("Завершение программы")
<code///>
Если возникнет исключение в результате преобразования строки в число, то оно будет обработано блоком except ValueError. Если же второе число будет равно нулю, то есть будет деление на ноль, тогда возникнет исключение ZeroDivisionError, и оно будет обработано блоком except ZeroDivisionError.

Тип BaseException представляет общее исключение, под которое попадают все исключительные ситуации. Поэтому в данном случае любое исключение, которое не представляет тип ValueError или ZeroDivisionError, будет обработано в блоке except BaseException:.

Однако, если в программе возникает исключение типа, для которого нет соответствующего блока except, то программа не сможет найти соответствующий блок except и сгенерирует исключение. Например, в следующем случае:
<code///>
try:
    number1 = int(input("Введите первое число: "))
    number2 = int(input("Введите второе число: "))
    print("Результат деления:", number1/number2)
except ZeroDivisionError:
    print("Попытка деления числа на ноль")
print("Завершение программы")
<code///>
Здесь предусмотрена обработка деления на ноль с помощью блока except ZeroDivisionError. Однако если пользователь вместо числа введет некорвертиуремую в число в строку, то возникнет исключение типа ValueError, для которого нет соответствующего блока except. И поэтому программа аварийно завершит свое выполнение.

Python позволяет в одном блоке except обрабатывать сразу несколько типов исключений. В этом случае все типы исключения передаются в скобках:
<code///>	
try:
    number1 = int(input("Введите первое число: "))
    number2 = int(input("Введите второе число: "))
    print("Результат деления:", number1/number2)
except (ZeroDivisionError, ValueError):    #  обработка двух типов исключений - ZeroDivisionError и ValueError
    print("Попытка деления числа на ноль или некорректный ввод")
 
print("Завершение программы")
<code///>
Получение информации об исключении

С помощью оператора as мы можем передать всю информацию об исключении в переменную, которую затем можно использовать в блоке except:
<code///>	
try:
    number = int(input("Введите число: "))
    print("Введенное число:", number)
except ValueError as e:
    print("Сведения об исключении", e)
print("Завершение программы")
<code///>
Пример некорректного ввода:

Введите число: fdsf
Сведения об исключении invalid literal for int() with base 10: 'fdsf'
Завершение программы
Генерация исключений и оператор raise

Иногда возникает необходимость вручную сгенерировать то или иное исключение. Для этого применяется оператор raise. Например, сгенерируем исключение
<code///>	
try:
    age = int(input("Введите возраст: "))
    if age > 110 or age < 1:
        raise Exception("Некорректный возраст")
    print("Ваш возраст:", age)
except ValueError:
    print("Введены некорректные данные")
except Exception as e:
    print(e)
print("Завершение программы")
<code///>
Оператору raise передается объект BaseException - в данном случае объект Exception. В конструктор этого типа можно ему передать сообщение, которое затем можно вывести пользователю. В итоге, если age будет больше 110 или меньше 1, то сработает оператор raise, который сгенерирует исключение. В итоге управление программой перейдет к блоку except, который обрабатывает исключения типа Exception:

Введите возраст: 100500
Некорректный возраст
Завершение программы