Диапазоны или range представляют неизменяемый последовательный набор чисел. Для создания диапазов применяетя range, которая имеет следующие формы:
<code///>
    range(stop): возвращает все целые числа от 0 до stop

    range(start, stop): возвращает все целые числа в промежутке от start (включая) до stop (не включая).

    range(start, stop, step): возвращает целые числа в промежутке от start (включая) до stop (не включая), которые увеличиваются на значение step
<code///>
Примеры вызовов функции range:
<code///>
range(5)            # 0, 1, 2, 3, 4
range(1, 5)         # 1, 2, 3, 4
range(2, 10, 2)     # 2, 4, 6, 8
range(10, 2, -2)    # 10 8 6 4 
<code///>
Диапазоны чаще всего применяются в циклах for. Например, выведем последовательно все числа от 0 до 4:
<code///>
for i in range(5):
    print(i, end=" ")
 
# Консольный вывод
# 0, 1, 2, 3, 4
<code///>
Другой пример выведем таблицу умножения:
<code///>	
for i in range(1, 10):
    for j in range(1, 10):
        print(i * j, end="\t")
    print("\n")
<code///>

1	2	3	4	5	6	7	8	9	

2	4	6	8	10	12	14	16	18	

3	6	9	12	15	18	21	24	27	

4	8	12	16	20	24	28	32	36	

5	10	15	20	25	30	35	40	45	

6	12	18	24	30	36	42	48	54	

7	14	21	28	35	42	49	56	63	

8	16	24	32	40	48	56	64	72	

9	18	27	36	45	54	63	72	81	

Если нам необходим последовательный список чисел, то для его создания удобно использовать функцию range:
<code///>
numbers = list(range(10))
print(numbers)      # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
numbers = list(range(2, 10))
print(numbers)      # [2, 3, 4, 5, 6, 7, 8, 9]
numbers = list(range(10, 2, -2))
print(numbers)      # [10, 8, 6, 4]
<code///>
Преимуществом диапазонов над стандартными списками и кортежами является то, что диапазон всегда будет занимать одно и то же небольшое количество памяти вне зависимости от того, какой набор чисел представляет этот диапазон. В действительности диапазон хранит только начальное, конечное значение и приращение.
[b]Словари[/b]
Словарь (dictionary) в языке Python хранит коллекцию элементов, где каждый элемент имеет уникальный ключ и ассоциированое с ним некоторое значение.

Определение словаря имеет следующий синтаксис:
<code///>
dictionary = { ключ1:значение1, ключ2:значение2, ....}
<code///>
В фигурных скобках через запятую определяется последовательность элементов, где для каждого элемента сначала указывается ключ и через двоеточие его значение.

Определим словарь:
<code///>
users = {1: "Tom", 2: "Bob", 3: "Bill"}
<code///>
В словаре users в качестве ключей используются числа, а в качестве значений - строки. То есть элемент с ключом 1 имеет значение "Tom", элемент с ключом 2 - значение "Bob" и т.д.

Другой пример:
<code///>
emails = {"tom@gmail.com": "Tom", "bob@gmai.com": "Bob", "sam@gmail.com": "Sam"}
<code///>
В словаре emails в качестве ключей используются строки - электронные адреса пользователей и в качестве значений тоже строки - имена пользователей.

Но необязательно ключи и строки должны быть однотипными. Они могу представлять разные типы:
<code///>
objects = {1: "Tom", "2": True, 3: 100.6}
<code///>
Мы можем также вообще определить пустой словарь без элементов:
<code///>
objects = {}
<code///>
или так:
<code///>
objects = dict()
<code///>
Преобразование списков и кортежей в словарь

Несмотря на то, что словарь и список - непохожие по структуре типы, но тем не менее существует возможности для отдельных видов списков преобразования их в словарь с помощью встроенной функции dict(). Для этого список должен хранить набор вложенных списков. Каждый вложенный список должен состоять из двух элементов - при конвертации в словарь первый элемент станет ключом, а второй - значением:
<code///>
users_list = [
    ["+111123455", "Tom"],
    ["+384767557", "Bob"],
    ["+958758767", "Alice"]
]
users_dict = dict(users_list)
print(users_dict)      # {"+111123455": "Tom", "+384767557": "Bob", "+958758767": "Alice"}
<code///>
Подобным образом можно преобразовать в словарь двухмерные кортежи, которые в свою очередь содержать кортежи из двух элементов:
<code///>
users_tuple = (
    ("+111123455", "Tom"),
    ("+384767557", "Bob"),
    ("+958758767", "Alice")
)
users_dict = dict(users_tuple)
print(users_dict)
<code///>
Получение и изменение элементов

Для обращения к элементам словаря после его названия в квадратных скобках указывается ключ элемента:
<code///>
dictionary[ключ]
<code///>
Например, получим и изменим элементы в словаре:
<code///>
users = {
    "+11111111": "Tom",
    "+33333333": "Bob",
    "+55555555": "Alice"
}
 
# получаем элемент с ключом "+11111111"
print(users["+11111111"])      # Tom
 
# установка значения элемента с ключом "+33333333"
users["+33333333"] = "Bob Smith"
print(users["+33333333"])   # Bob Smith
<code///>
Если при установки значения элемента с таким ключом в словаре не окажется, то произойдет его добавление:
<code///>	
users["+4444444"] = "Sam"
<code///>
Но если мы попробуем получить значение с ключом, которого нет в словаре, то Python сгенерирует ошибку KeyError:
<code///>
user = users["+4444444"]    # KeyError
<code///>
И чтобы предупредить эту ситуацию перед обращением к элементу мы можем проверять наличие ключа в словаре с помощью выражения ключ in словарь. Если ключ имеется в словаре, то данное выражение возвращает True:
<code///>
key = "+4444444"
if key in users:
    user = users[key]
    print(user)
else:
    print("Элемент не найден")
<code///>
Также для получения элементов можно использовать метод get, который имеет две формы:

    get(key): возвращает из словаря элемент с ключом key. Если элемента с таким ключом нет, то возвращает значение None

    get(key, default): возвращает из словаря элемент с ключом key. Если элемента с таким ключом нет, то возвращает значение по умолчанию default

<code///>
users = {
    "+11111111": "Tom",
    "+33333333": "Bob",
    "+55555555": "Alice"
}
 
user1 = users.get("+55555555")
print(user1)    # Alice
user2 = users.get("+33333333", "Unknown user")
print(user2)    # Bob
user3 = users.get("+44444444", "Unknown user")
print(user3)    # Unknown user
<code///>
Удаление

Для удаления элемента по ключу применяется оператор del:
<code///>
users = {
    "+11111111": "Tom",
    "+33333333": "Bob",
    "+55555555": "Alice"
}
 
del users["+55555555"]
print(users)    # { "+11111111": "Tom", "+33333333": "Bob"}
<code///>
Но стоит учитывать, что если подобного ключа не окажется в словаре, то будет выброшено исключение KeyError. Поэтому опять же перед удалением желательно проверять наличие элемента с данным ключом.
<code///>
users = {
    "+11111111": "Tom",
    "+33333333": "Bob",
    "+55555555": "Alice"
}
 
key = "+55555555"
if key in users:
    del users[key]
    print(f"Элемент с ключом {key} удален")
else:
    print("Элемент не найден")
<code///>
Другой способ удаления представляет метод pop(). Он имеет две формы:

    pop(key): удаляет элемент по ключу key и возвращает удаленный элемент. Если элемент с данным ключом отсутствует, то генерируется исключение KeyError

    pop(key, default): удаляет элемент по ключу key и возвращает удаленный элемент. Если элемент с данным ключом отсутствует, то возвращается значение default

<code///>
users = {
    "+11111111": "Tom",
    "+33333333": "Bob",
    "+55555555": "Alice"
}
key = "+55555555"
user = users.pop(key)
print(user)     # Alice
 
user = users.pop("+4444444", "Unknown user")
print(user)     # Unknown user
<code///>
Если необходимо удалить все элементы, то в этом случае можно воспользоваться методом clear():
<code///>
users.clear()
<code///>
Копирование и объединение словарей

Метод copy() копирует содержимое словаря, возвращая новый словарь:
<code///>
users = {"+1111111": "Tom", "+3333333": "Bob", "+5555555": "Alice"}
students = users.copy()
print(students)     # {"+1111111": "Tom", "+3333333": "Bob", "+5555555": "Alice"}
<code///>
Метод update() объединяет два словаря:
<code///>
users = {"+1111111": "Tom", "+3333333": "Bob"}
 
users2 = {"+2222222": "Sam", "+6666666": "Kate"}
users.update(users2)
 
print(users)    # {"+1111111": "Tom", "+3333333": "Bob", "+2222222": "Sam", "+6666666": "Kate"}
print(users2)   # {"+2222222": "Sam", "+6666666": "Kate"}
<code///>
При этом словарь users2 остается без изменений. Изменяется только словарь users, в который добавляются элементы другого словаря. Но если необходимо, чтобы оба исходных словаря были без изменений, а результатом объединения был какой-то третий словарь, то можно предварительно скопировать один словарь в другой:
<code///>
users3 = users.copy()
users3.update(users2)
<code///>
Перебор словаря

Для перебора словаря можно воспользоваться циклом for:
<code///>
users = {
    "+11111111": "Tom",
    "+33333333": "Bob",
    "+55555555": "Alice"
}
for key in users:
    print(f"Phone: {key}  User: {users[key]} ")
<code///>
При переборе элементов мы получаем ключ текущего элемента и по нему можем получить сам элемент.

Другой способ перебора элементов представляет использование метода items():
<code///>
users = {
    "+11111111": "Tom",
    "+33333333": "Bob",
    "+55555555": "Alice"
}
for key, value in users.items():
    print(f"Phone: {key}  User: {value} ")
<code///>
Метод items() возвращает набор кортежей. Каждый кортеж содержит ключ и значение элемента, которые при переборе мы тут же можем получить в переменные key и value.

Также существуют отдельно возможности перебора ключей и перебора значений. Для перебора ключей мы можем вызвать у словаря метод keys():
<code///>
for key in users.keys():
    print(key)
<code///>
Правда, этот способ перебора не имеет смысла, так как и без вызова метода keys() мы можем перебрать ключи, как было показано выше.

Для перебора только значений мы можем вызвать у словаря метод values():
<code///>
for value in users.values():
    print(value)
<code///>
Комплексные словари

Кроме простейших объектов типа чисел и строк словари также могут хранить и более сложные объекты - те же списки, кортежи или другие словари:
<code///>
users = {
    "Tom": {
        "phone": "+971478745",
        "email": "tom12@gmail.com"
    },
    "Bob": {
        "phone": "+876390444",
        "email": "bob@gmail.com",
        "skype": "bob123"
    }
}
<code///>
В данном случае значение каждого элемента словаря в свою очередь представляет отдельный словарь.

Для обращения к элементам вложенного словаря соответственно необходимо использовать два ключа:
<code///>
old_email = users["Tom"]["email"]
users["Tom"]["email"] = "supertom@gmail.com"
print(users["Tom"])     # { phone": "+971478745", "email": "supertom@gmail.com }
<code///>
Но если мы попробуем получить значение по ключу, который отсутствует в словаре, Python сгенерирует исключение KeyError:
<code///>
tom_skype = users["Tom"]["skype"]   # KeyError
<code///>
Чтобы избежать ошибки, можно проверять наличие ключа в словаре:
<code///>
key = "skype"
if key in users["Tom"]:
    print(users["Tom"]["skype"])
else:
    print("skype is not found")
<code///>
Либо в качестве альтернативы можно использовать метод get():
<code///>	
users = {
    "Tom": {
        "phone": "+971478745",
        "email": "tom12@gmail.com"
    }
}
 
tom_skype = users["Tom"].get("skype", "Undefined")
print(tom_skype)    # Undefined
<code///>