Модуль в языке Python представляет отдельный файл с кодом, который можно повторно использовать в других программах.

Для создания модуля необходимо создать собственно файл с расширением *.py, который будет представлять модуль. Название файла будет представлять название модуля. Затем в этом файле надо определить одну или несколько функций.

Допустим, основной файл программы называется main.py. И мы хотим подключить к нему внешние модули.

Для этого сначала определим новый модуль: создадим в той же папке, где находится main.py, новый файл, который назовем message.py. По умолчанию интерпретатор Python ищет модули по ряду стандартных путей, один из которых - это папка главного, запускаемого скрипта. Поэтому, чтобы интерпретатор подхватил модуль message.py, для простоты оба файла поместим в один проект.

Соответственно модуль будет называться message. Определим в нем следующий код:
<code///>
hello = "Hello all"
 
 
def print_message(text):
    print(f"Message: {text}")
<code///>
Здесь определена переменная hello и функция print_message, которая в качестве параметра получает некоторый текст и выводит его на консоль.

В основном файле программы - main.py используем данный модуль:
<code///>
import message      # подключаем модуль message
 
# выводим значение переменной hello
print(message.hello)        # Hello all
# обращаемся к функции print_message
message.print_message("Hello work")  # Message: Hello work
<code///>
Для использования модуля его надо импортировать с помощью оператора import, после которого указывается имя модуля: import message.

Чтобы обращаться к функциональности модуля, нам нужно получить его пространство имен. По умолчанию оно будет совпадать с именем модуля, то есть в нашем случае также будет называться message.

Получив пространство имен модуля, мы сможем обратиться к его функциям по схеме
пространство_имен.функция

Например, обращение к функции print_message() из модуля message:
<code///>
message.print_message("Hello work")
<code///>
И после этого мы можем запустить главный скрипт main.py, и он задействует модуль message.py. В частности, консольный вывод будет следующим:

Hello all
Message: Hello work

Подключение функциональности модуля в глобальное пространство имен

Другой вариант настройки предполагает импорт функциональности модуля в глобальное пространство имен текущего модуля с помощью ключевого слова from:
<code///>
from message import print_message
 
# обращаемся к функии print_message из модуля message
print_message("Hello work")  # Message: Hello work
 
# переменная hello из модуля message не доступна, так как она не импортирована
# print(message.hello)   
# print(hello) 
<code///>
В данном случае мы импортируем из модуля message в глобальное пространство имен функцию print_message(). Поэтому мы сможем ее использовать без указания пространства имен модуля как если бы она была определена в этом же файле.

Все остальные функции, переменные из модуля недоступны (как например, в примере выше переменная hello). Если мы хотим их также использовать, то их можно подключить по отдельности:
<code///>
from message import print_message
from message import hello
 
# обращаемся к функции print_message из модуля message
print_message("Hello work")  # Message: Hello work
 
# обращаемся к переменной hello из модуля message
print(hello)    # Hello all
<code///>
Если необходимо импортировать в глобальное пространство имен весь функционал, то вместо названий отдельных функций и переменных можно использовать символ зводочки *:
<code///>
from message import *
 
# обращаемся к функции print_message из модуля message
print_message("Hello work")  # Message: Hello work
 
# обращаемся к переменной hello из модуля message
print(hello)    # Hello all
<code///>
Но стоит отметить, что импорт в глобальное пространство имен чреват коллизиями имен функций. Например, если у нас том же файле определена функция с тем же именем до ее вызова, то будет вызываться функция, которая определена последней:
<code///>
from message import *
  
print_message("Hello work")  # Message: Hello work - применяется функция из модуля message
 
def print_message(some_text):
    print(f"Text: {some_text}")
  
print_message("Hello work")  # Text: Hello work - применяется функция из текущего файла
<code///>
Таким образом, одноименная функция текущего файла скрывает функцию из подключенного модуля.
Установка псевдонимов

При импорте модуля и его функциональности мы можем установить для них псевдонимы. Для этого применяется ключевое слово as, после которого указывается псевдоним. Например, установим псевдоним для модуля:
<code///>
import message as mes  # модуль message проецируется на псевдоним mes
 
# выводим значение переменной hello
print(mes.hello)        # Hello all
# обращаемся к функии print_message
mes.print_message("Hello work")  # Message: Hello work
<code///>
В данном случае пространство имен будет называться mes, и через этот псевдоним можно обращаться к функциональности модуля.

Подобным образом можно установить псевдонимы для отдельной функциональности модуля:
<code///>
from message import print_message as display
from message import hello as welcome
 
print(welcome)          # Hello all - переменная hello из модуля message
display("Hello work")   # Message: Hello work - функция print_message из модуля message
<code///>
Здесь для функции print_message из модуля message устанавливается псевдоним display, а для переменной hello - псевдоним welcome. И через эти псевдонимы мы сможем к ним обращаться.

Псевдонимы могут быть полезны, когда нас не устраивают имена функций и переменных, например, они слишком длинные, и мы хотим их сократить, либо мы хотим дать им более описательные, с нашей точки зрения, имена. Либо если в текущем файле уже есть функциональность с теми же именами, и с помощью установки псевдонимов мы можем избежать конфликта имен. Например:
<code///>
from message import print_message as display
 
def print_message(some_text):
    print(f"Text: {some_text}")
 
# функция print_message из модуля message
display("Hello work")       # Message: Hello work
 
# функция print_message из текущего файла
print_message("Hello work")  # Text: Hello work
<code///>
Имя модуля

В примере выше модуль main.py, который является главным, использует модуль message.py. При запуске модуля main.py программа выполнит всю необходимую работу. Однако, если мы запустим отдельно модуль message.py сам по себе, то ничего на консоли не увидим. Ведь модуль message просто определяет функцию и переменную и не выполняет никаких других действий. Но мы можем сделать так, чтобы модуль message.py мог использоваться как сам по себе, так и подключаться в другие модули.

При выполнении модуля среда определяет его имя и присваивает его глобальной переменной __name__ (с обеих сторон по два подчеркивания). Если модуль является запускаемым, то его имя равно __main__ (также по два подчеркивания с каждой стороны). Если модуль используется в другом модуле, то в момент выполнения его имя аналогично названию файла без расширения py. И мы можем это использовать. Так, изменим содержимое файла message.py:
<code///>
hello = "Hello all"
 
 
def print_message(text):
    print(f"Message: {text}")
 
 
def main():
    print_message(hello)
 
 
if __name__ == "__main__": 
    main()
<code///>
В данном случае в модуль message.py для тестирования функциональности модуля добавлена функция main. И мы можем сразу запустить файл message.py отдельно от всех и протестировать код.

Следует обратить внимание на вызов функции main:
<code///>
if __name__ == "__main__":
    main()
<code///>
Переменная __name__ указывает на имя модуля. Для главного модуля, который непосредственно запускается, эта переменная всегда будет иметь значение __main__ вне зависимости от имени файла.

Поэтому, если мы будем запускать скрипт message.py отдельно, сам по себе, то Python присвоит переменной __name__ значение __main__, далее в выражении if вызовет функцию main из этого же файла.

Однако если мы будем запускать другой скрипт, а этот - message.py - будем подключать в качестве вспомогательного, для message.py переменная __name__ будет иметь значение message. И соответственно метод main в файле message.py не будет работать.

Данный подход с проверкой имени модуля является более рекомендуемым подходом, чем просто вызов метода main.

В файле main.py также можно сделать проверку на то, является ли модуль главным (хотя в прицнипе это необязательно):
<code///>
import message
 
 
def main(): 
    message.print_message("Hello work")  # Message: Hello work
 
 
if __name__ == "__main__":
    main()
<code///>
Python предоставляет ряд встроенных модулей, которые мы можем использовать в своих программах. В следующих статьях рассмотрим основные из них.
[b]Модуль random[/b]
Модуль random управляет генерацией случайных чисел. Его основные функции:

    random(): генерирует случайное число от 0.0 до 1.0

    randint(): возвращает случайное число из определенного диапазона

    randrange(): возвращает случайное число из определенного набора чисел

    shuffle(): перемешивает список

    choice(): возвращает случайный элемент списка

Функция random() возвращает случайное число с плавающей точкой в промежутке от 0.0 до 1.0. Если же нам необходимо число из большего диапазона, скажем от 0 до 100, то мы можем соответственно умножить результат функции random на 100.
<code///>
import random
 
number = random.random()  # значение от 0.0 до 1.0
print(number)
number = random.random() * 100  # значение от 0.0 до 100.0
print(number)
<code///>
Функция randint(min, max) возвращает случайное целое число в промежутке между двумя значениями min и max.
<code///>
import random
 
number = random.randint(20, 35)  # значение от 20 до 35
print(number)
<code///>
Функция randrange() возвращает случайное целое число из определенного набора чисел. Она имеет три формы:

    randrange(stop): в качестве набора чисел, из которых происходит извлечение случайного значения, будет использоваться диапазон от 0 до числа stop

    randrange(start, stop): набор чисел представляет диапазон от числа start до числа stop

    randrange(start, stop, step): набор чисел представляет диапазон от числа start до числа stop, при этом каждое число в диапазоне отличается от предыдущего на шаг step

<code///>
import random
 
number = random.randrange(10)  # значение от 0 до 10 не включая
print(number)
number = random.randrange(2, 10)  # значение в диапазоне 2, 3, 4, 5, 6, 7, 8, 9
print(number)
number = random.randrange(2, 10, 2)  # значение в диапазоне 2, 4, 6, 8
print(number)
<code///>
Работа со списком

Для работы со списками в модуле random определены две функции: функция shuffle() перемешивает список случайным образом, а функция choice() возвращает один случайный элемент из списка:
<code///>
numbers = [1, 2, 3, 4, 5, 6, 7, 8]
random.shuffle(numbers)
print(numbers)  
random_number = random.choice(numbers)
print(random_number)
<code///>
[b]Математические функции и модуль math[/b]
Встроенный модуль math в Python предоставляет набор функций для выполнения математических, тригонометрических и логарифмических операций. Некоторые из основных функций модуля:

    pow(num, power): возведение числа num в степень power

    sqrt(num): квадратный корень числа num

    ceil(num): округление числа до ближайшего наибольшего целого

    floor(num): округление числа до ближайшего наименьшего целого

    factorial(num): факториал числа

    degrees(rad): перевод из радиан в градусы

    radians(grad): перевод из градусов в радианы

    cos(rad): косинус угла в радианах

    sin(rad): синус угла в радианах

    tan(rad): тангенс угла в радианах

    acos(rad): арккосинус угла в радианах

    asin(rad): арксинус угла в радианах

    atan(rad): арктангенс угла в радианах

    log(n, base): логарифм числа n по основанию base

    log10(n): десятичный логарифм числа n

Пример применения некоторых функций:
<code///>
import math
 
# возведение числа 2 в степень 3
n1 = math.pow(2, 3)
print(n1)  # 8
 
# ту же самую операцию можно выполнить так
n2 = 2**3
print(n2)
 
# квадратный корень числа
print(math.sqrt(9))  # 3
 
# ближайшее наибольшее целое число
print(math.ceil(4.56))  # 5
 
# ближайшее наименьшее целое число
print(math.floor(4.56))  # 4
 
# перевод из радиан в градусы
print(math.degrees(3.14159))  # 180
 
# перевод из градусов в радианы
print(math.radians(180))   # 3.1415.....
# косинус
print(math.cos(math.radians(60)))  # 0.5
# cинус
print(math.sin(math.radians(90)))   # 1.0
# тангенс
print(math.tan(math.radians(0)))    # 0.0
 
print(math.log(8,2))    # 3.0
print(math.log10(100))    # 2.0
<code///>
Также модуль math предоставляет ряд встроенных констант, такие как PI и E:
<code///>
import math
radius = 30
# площадь круга с радиусом 30
area = math.pi * math.pow(radius, 2)
print(area)
 
# натуральный логарифм числа 10
number = math.log(10, math.e)
print(number)
<code///>
Дополнительные математические функции

Стоит отметить, что в Python имеется еще ряд встроенных функций, которые выполняют некоторые математические вычисления, но не входят в модуль math. Отмечу некоторые:

    abs: возвращает абсолютное значение числа

    min: возвращает минимальное значение из списка

    max: возвращает максимальное значение из списка

Например, найдем "расстояние" между двумя числа (абсолютную разность без учета знака):
<code///>
num1 = 3
num2 = 8
diff = abs(num1-num2)  # 5
print(diff)   # 5
<code///>
Или найдем минимальное и максимальное число в списке:
<code///>
numbers = [54, 23, 1, 4, 657, 2, -3, 56, 24]
 
min_number = min(numbers)  # -3
max_number = max(numbers)  # 657
print("min:", min_number) 
print("max:", max_number)<code///>